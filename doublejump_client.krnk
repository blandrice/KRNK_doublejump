# ===================================================================
# SETTINGS:
num MAX_JUMPCOUNT = 2; # 2 is "doublejump", 3 is "triplejump"
bool WALLJUMP_REFRESHS = true;
bool ENABLE_CROUCHJUMP = true; # lower height for crouch jump, also
                                # applies "moonjump" mid-air physics
num SOUND = 31960; # sound ID. set to 0 if no sound desired

# HARD-CODED NUMBERS - DON'T TOUCH
num MS_DURATION_UNCROUCH = 166;
num HEIGHT_JUMP = 0.0793; # 60FPS, max clearance 17.9 units
num HEIGHT_CROUCHJUMP = 0.0595; # 60FPS, max clearance 10.2 units
# ===================================================================
<<<<<<< Updated upstream

# Runs when the game starts
public action start() {
=======
>>>>>>> Stashed changes

obj updateState = { updateId: 0, playerUpdateId: 0, lastUpdate: 0 };
obj currentPlayerState = {};
obj[] playerStateHistory = obj[];

obj action findHistoryState() {
    # Current state that was synced up was the last state
    obj currentState = playerStateHistory[lengthOf playerStateHistory - 1];
    obj[] possibleStates = obj[];
    num highestMatches = 0;

    # check all 6 position/velocity numbers will match a state
    for(num i = lengthOf playerStateHistory - 2; i >= 0; i--) {
        obj historyState = playerStateHistory[i];
        num totalMatches = 0;
        num tolerance = 0.01;

        if(Math.abs((num)historyState.position.x - (num)currentState.position.x) < tolerance) { totalMatches++; } 
        if(Math.abs((num)historyState.position.y - (num)currentState.position.y) < tolerance) { totalMatches++; } 
        if(Math.abs((num)historyState.position.z - (num)currentState.position.z) < tolerance) { totalMatches++; } 
        if(Math.abs((num)historyState.velocity.x - (num)currentState.velocity.x) < tolerance) { totalMatches++; } 
        if(Math.abs((num)historyState.velocity.y - (num)currentState.velocity.y) < tolerance) { totalMatches++; } 
        if(Math.abs((num)historyState.velocity.z - (num)currentState.velocity.z) < tolerance) { totalMatches++; } 

        if(totalMatches == 6) {
			# GAME.log(lengthOf playerStateHistory - i);
            return playerStateHistory[i];
        }
        if(totalMatches > highestMatches) {
            highestMatches = totalMatches;
        }
        addTo possibleStates {state: playerStateHistory[i], totalMatches: totalMatches, id: lengthOf playerStateHistory - i };
    }
    # Rest is error logging
    GAME.log("Failed to find state history", GAME.TIME.now());
	GAME.log("Highest matches: ", highestMatches);
    for(num i = 0; i < lengthOf possibleStates; i++) {
        if((num)possibleStates[i].totalMatches == highestMatches) {
            GAME.log("Index: ", possibleStates[i].id);
            return (obj)possibleStates[i].state;
        }
    }
    return currentPlayerState;
}

<<<<<<< Updated upstream
# Runs every game tick
public action update(num delta) {

}

# Add rendering logic in here
public action render(num delta) {

}

# Player spawns in
public action onPlayerSpawn(str id) {

=======
bool syncStarted = false;
# Runs every game tick
public action update(num delta) {
    syncStarted = false;
>>>>>>> Stashed changes
}

num jumpCount = 0;
bool hasJumped = false;
num timeLastCrouched = GAME.TIME.now();

# Player update
public action onPlayerUpdate(str id, num delta, obj inputs) {
    obj player = GAME.PLAYERS.getSelf();
    num timeNow = GAME.TIME.now();
    (num) updateState.playerUpdateId++;

    # Syncing: We got a sync, so reset the current player state to the correct history
    if(!syncStarted && timeNow == (num)updateState.lastUpdate)
    {
        syncStarted = true;
        currentPlayerState = findHistoryState();
        # sync done, throw out old values
        playerStateHistory = obj[];
    }

    # Double-Jump stuff
    if ((bool) inputs.crouch) {
        player.timeLastCrouched = timeNow;
    }
    if((bool) player.onGround) {
<<<<<<< Updated upstream
        jumpCount = 0;
    } else if (WALLJUMP_REFRESHS && (bool) player.onWall && (bool) inputs.jump) {
        jumpCount = 1;
    }
    if((bool) inputs.jump && jumpCount < MAX_JUMPCOUNT) {
        if(!hasJumped) {
            if(jumpCount > 0) {
				# if ((num) inputs.crouch) {
				if (ENABLE_CROUCHJUMP && ((timeNow - timeLastCrouched) < MS_DURATION_UNCROUCH)) {
					player.velocity.y = Math.lerp(HEIGHT_CROUCHJUMP,HEIGHT_JUMP,(timeNow - timeLastCrouched)/MS_DURATION_UNCROUCH);	# "moonjumping" calculation
                    GAME.log(toStr Math.lerp(HEIGHT_CROUCHJUMP,HEIGHT_JUMP,(timeNow - timeLastCrouched)/MS_DURATION_UNCROUCH));
				} else {
					player.velocity.y = HEIGHT_JUMP;	
				}
                
            }
            jumpCount++;
            hasJumped = true;
        }
=======
        currentPlayerState.jumpCount = MAX_JUMPCOUNT-1;
    } else if (WALLJUMP_REFRESHS && (bool) player.onWall && (bool) inputs.jump) {
        currentPlayerState.jumpCount = MAX_JUMPCOUNT-1;
    } 
    if((bool) inputs.jump) {
        if(!(bool)currentPlayerState.hasJumped  && (num)currentPlayerState.jumpCount > 0 && !(bool)player.onGround) {
            if (!(bool) player.onWall && WALLJUMP_REFRESHS) {
                if (ENABLE_CROUCHJUMP && ((timeNow - (num) player.timeLastCrouched) < MS_DURATION_UNCROUCH)) {
                    player.velocity.y = Math.lerp(HEIGHT_CROUCHJUMP,HEIGHT_JUMP,(timeNow - (num)player.timeLastCrouched)/MS_DURATION_UNCROUCH);	# "moonjumping" calculation
                } else {
                    player.velocity.y = HEIGHT_JUMP;	
                }
                if (SOUND > 0) {
                    GAME.SOUND.play2D(32576, 1, 0.5, false); # jump sound
                }
                (num)currentPlayerState.jumpCount--;
            }
        }
        currentPlayerState.hasJumped = true;
>>>>>>> Stashed changes
    }
    else {
        currentPlayerState.hasJumped = false;
    }

    # Sync saving old player states
    addTo playerStateHistory {
        # Data to use in an attempt to find the correct state in history
        position: {x: player.position.x, y: player.position.y, z: player.position.z },
        velocity: {x: player.velocity.x, y: player.velocity.y, z: player.velocity.z },
        # Actual data we want to save
        jumpCount: currentPlayerState.jumpCount,
        hasJumped: currentPlayerState.hasJumped,
        time: GAME.TIME.now(),
        timeLastCrouched: player.timeLastCrouched
    };
    updateState.lastUpdate = GAME.TIME.now();    
}

<<<<<<< Updated upstream
# User held a key
public action onKeyHeld(str key, num code) {

}

# User clicked on screen
public action onMouseClick(num button, num x, num y) {

}

# User released clicked on screen
public action onMouseUp(num button, num x, num y) {

}

# User scrolled on screen
public action onMouseScroll(num dir) {

}

# User clicked a DIV (ID)
public action onDIVClicked(str id) {

}

# Client receives network message
public action onNetworkMessage(str id, obj data) {

=======
public action onPlayerSpawn(str id) {
    updateState.updateId = 0;
    updateState.playerUpdateId = 0;
>>>>>>> Stashed changes
}